#' EES-ily generate some beefy test files
#'
#' Mostly for ease of performance benchmarking. A bit crude, only does
#' PCons for simplicity so far.
#'
#' @param years A vector of 4 digit years
#' @param pcon_names A vector of PCon names
#' @param pcon_codes A vector of PCon codes
#' @param num_filters The number of filters to generate, currently
#' will give each filter 5 items
#' @param num_indicators The number of indicators to generate, currently
#' generates random numbers between 100 and 1000
#' @param verbose Optional console messages highlighting the number of
#' rows being created
#'
#' @export
#' @return A list containing two data frames, one data and associated meta
#'
#' @examples
#' generate_test_dfs(2010:2015, "Sheffield Central", "E14000919", 2, 3)
generate_test_dfs <- function(
  years = 3000,
  pcon_names = "Sheffield Central",
  pcon_codes = "E14000919",
  num_filters = 1,
  num_indicators = 1,
  verbose = FALSE
) {
  file_pair <- list(
    data = generate_data_file(
      years,
      pcon_names,
      pcon_codes,
      num_filters,
      num_indicators,
      verbose = verbose
    ),
    meta = generate_meta_file(num_filters, num_indicators)
  )

  return(file_pair)
}

#' Generate a data file for testing
#'
#' This function is designed to be used within `generate_test_dfs` to
#' complement the meta file generated by `generate_meta_file`.
#'
#' Use the parameters to quickly create beefy files!
#'
#' @keywords internal
#'
#' @inheritParams generate_test_dfs
#'
#' @returns A data frame following the EES data standards
generate_data_file <- function(
  years,
  pcon_names,
  pcon_codes,
  num_filters,
  num_indicators,
  verbose = FALSE
) {
  filter_values <- c(
    "Alpha",
    "Bravo",
    "Charlie",
    "Delta",
    "Echo"
  )

  if (verbose) {
    cli::cli_alert_info(
      paste(
        "Expecting to generate",
        format(
          length(years) *
            length(pcon_codes) *
            (length(filter_values)^num_filters),
          big.mark = ","
        ),
        "rows..."
      )
    )
  }

  # Prepare all combinations of years, pcon_names, pcon_codes, and filter values
  if (verbose) {
    cli::cli_alert_info("Preparing filter combinations...")
  }
  filter_values_list <- replicate(num_filters, filter_values, simplify = FALSE)
  filter_combinations <- expand.grid(
    filter_values_list,
    stringsAsFactors = FALSE
  )
  names(filter_combinations) <- paste0("filter", seq_len(num_filters))

  total_rows <- 0
  test_data <- data.frame()

  # Vectorized approach for speed
  n_years <- length(years)
  n_pcon <- length(pcon_codes)
  n_filters <- nrow(filter_combinations)
  total_rows <- n_years * n_pcon * n_filters

  if (verbose) {
    cli::cli_alert_info(
      "Expanding all combinations of years, pcon_codes, and filters..."
    )
  }
  df <- expand.grid(
    year = years,
    pcon_idx = seq_along(pcon_codes),
    filter_row = seq_len(n_filters),
    KEEP.OUT.ATTRS = FALSE,
    stringsAsFactors = FALSE
  )

  if (verbose) {
    cli::cli_alert_info("Assigning core columns...")
  }
  test_data <- data.frame(
    time_period = df$year,
    time_identifier = "Calendar year",
    geographic_level = "Parliamentary constituency",
    country_name = "England",
    country_code = "E92000001",
    pcon_name = pcon_names[df$pcon_idx],
    pcon_code = pcon_codes[df$pcon_idx],
    stringsAsFactors = FALSE
  )

  if (verbose) {
    cli::cli_alert_info("Adding filter columns...")
  }
  for (f in seq_len(num_filters)) {
    test_data[[paste0("filter", f)]] <- filter_combinations[df$filter_row, f]
  }

  if (verbose) {
    cli::cli_progress_bar(
      "Randomly populating indicator columns...",
      total = num_indicators
    )
  }
  for (i in seq_len(num_indicators)) {
    if (verbose) {
      cli::cli_progress_update()
    }

    test_data[[paste0("indicator", i)]] <- sample(
      100:1000,
      total_rows,
      replace = TRUE
    )
  }

  if (verbose) {
    cli::cli_alert_success(
      paste(
        "Final dataframe has",
        format(nrow(test_data), big.mark = ","),
        "rows and",
        format(ncol(test_data), big.mark = ","),
        "columns"
      )
    )
  }

  return(test_data)
}

#' Generate a meta file for testing
#'
#' This function is designed to be used within `generate_test_dfs` to
#' complement the data file generated by `generate_data_file`.
#'
#' @param num_filters The number of filters to generate
#' @param num_indicators The number of indicators to generate
#'
#' @keywords internal
#' @returns A data frame following the EES metadata standards
generate_meta_file <- function(
  num_filters,
  num_indicators
) {
  cols <- c(
    paste0("filter", 1:num_filters),
    paste0("indicator", 1:num_indicators)
  )

  data.frame(
    col_name = cols,
    col_type = ifelse(grepl("^filter", cols), "Filter", "Indicator"),
    label = toupper(cols),
    indicator_grouping = NA,
    indicator_unit = NA,
    indicator_dp = NA,
    filter_hint = NA,
    filter_grouping_column = NA
  )
}
